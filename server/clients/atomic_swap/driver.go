package atomicswap

import (
	"context"
	"crypto/sha256"
	"encoding/json"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
	"github.com/threefoldtech/atomicswap/eth"
	goethclient "github.com/threefoldtech/web3_proxy/server/clients/eth"
	"github.com/threefoldtech/web3_proxy/server/clients/nostr"
	stellargoclient "github.com/threefoldtech/web3_proxy/server/clients/stellar"
)

type (
	// TradeManager manages a full trade. This can inlcude 1 or more swaps
	TradeManager struct {
		nostr *nostr.Client
		// buyer and seller are only used by the drivers, but are instantiated here so we can clone them into the driver when that is created
		buyer  BuyChain
		seller SellChain

		saleId string

		// This is used to negotiate trades
		msges <-chan nostr.NostrEvent

		// Total amount of tft's to swap
		totalAmount uint64
		// Amount currently being processed
		amountInProgress uint64
		// amount of other token to pay for 1 TFT
		swapPrice uint64
		// drivers currently active. A driver becomes active after a trade is successfully negotiated
		inflightTrades []*SwapDriver
	}

	// SwapDriver drives a single atomic swap. Multiple swap drivers can be in progress for the same swap
	SwapDriver struct {
		nostr  *nostr.Client
		buyer  BuyChain
		seller SellChain

		saleId       string
		swapId       string
		tradeDetails NegotiatedTrade

		stage DriverStage

		msges <-chan nostr.NostrEvent

		// Atomic swap secret and hash.
		secret     [32]byte
		secretHash [sha256.Size]byte

		// State tracking
		// Result of the init call. This is generated by the buyer and transfered to the seller.
		// The seller uses this to claim the tokens after the TFT have been transfered
		initResult any
	}

	// Driver for atomic swaps
	Driver struct {
		nostr   *nostr.Client
		eth     *goethclient.Client
		stellar *stellargoclient.Client

		saleId string
		swapId string

		stage DriverStage

		// amount of TFT to swap, this is initialized in a sell order to the maximum available
		swapAmount uint
		// amount of other token to pay
		swapPrice uint

		msges <-chan nostr.NostrEvent

		// temporary, this nees a better way
		sct *eth.SwapContractTransactor

		secret     [32]byte
		secretHash [sha256.Size]byte
	}

	DriverStage = int

	MsgBuy struct {
		SwapId string `json:"swapId"`
		Amount uint64 `json:"amount"`
	}

	MsgAcceptBuy struct {
		SwapId string `json:"swapId"`
		// Address on chain we are receiving payment
		SellAddress string `json:"sellAddress"`
		// Explicitly communicate accepted amount of TFT and value of 1 TFT

		// Amount of TFT to swap
		Amount uint64 `json:"amount"`
		// SwapPrice of 1 TFT
		SwapPrice uint64 `json:"swapPrice"`
	}

	MsgInitiate struct {
		SwapId         string            `json:"swapId"`
		SharedSecret   [sha256.Size]byte `json:"sharedSecret"`
		InitiateOutput any               `json:"initiateOutput"`
		StellarAddress string            `json:"stellarAddress"`
	}

	MsgParticipate struct {
		SwapId            string `json:"swapId"`
		ParticipateOutput any    `json:"participateOutput"`
		// HoldingAccount    string `json:"holdingAccount"`
		// RefundTx          string `json:"refundTx"`
	}

	MsgRedeemed struct {
		SwapId string   `json:"swapId"`
		Secret [32]byte `json:"secret"`
	}
)

const (
	// Initial conditions
	DriverStageOpenSale DriverStage = iota
	DriverStageStartBuy
	// In progress
	DriverStageAcceptedBuy
	DriverStageSetupSwap
	DriverStageParticipateSwap
	// Terminal conditions
	DriverStageClaimSwap
	DriverStageDone
)

const (
	// dialTimeout for dialing eth nodes
	dialTimeout = time.Second * 10
)

var (
	// contract address on the sepolia teest network
	contractAddress = common.HexToAddress("0x17f54245073bfed168a51c3d13b536e39e406063")
	// contract address on the goerli network
	// contractAddress = common.HexToAddress("0x8420c8271d602F6D0B190856Cea8E74D09A0d3cF")
	// TFT asset on the stellar testnet
	testnetTftAsset = stellargoclient.TestnetTft
)

func InitBuy(nostr *nostr.Client, buyer BuyChain, seller SellChain, totalAmount uint64, tokenPrice uint64) (*TradeManager, error) {
	tm := &TradeManager{
		nostr:  nostr,
		buyer:  buyer,
		seller: seller,

		totalAmount:    totalAmount,
		swapPrice:      tokenPrice,
		inflightTrades: []*SwapDriver{},
	}

	return tm, nil
}

func InitSell(nostr *nostr.Client, buyer BuyChain, seller SellChain, totalAmount uint64, tokenPrice uint64) (*TradeManager, error) {
	tm := &TradeManager{
		nostr:  nostr,
		buyer:  buyer,
		seller: seller,

		saleId: uuid.NewString(),

		totalAmount:    totalAmount,
		swapPrice:      tokenPrice,
		inflightTrades: []*SwapDriver{},
	}

	ch, err := nostr.SubscribeDirectMessagesDirect(tm.saleId)
	if err != nil {
		return nil, err
	}

	tm.msges = ch

	go handleMessage(tm)

	return tm, nil
}

func (tm *TradeManager) handleBuyMessage(ctx context.Context, sender string, msg MsgBuy) {
	// Price is the price we (the seller set)
	if tm.totalAmount == 0 {
		log.Info().Str("sale id", tm.saleId).Msg("Ignore buy message for sale which has not tokens left")
		return
	}

	tradedTokens := msg.Amount
	if msg.Amount > tm.totalAmount {
		tradedTokens = tm.totalAmount
	}

	trade := NegotiatedTrade{
		Amount: tradedTokens,
		Price:  tm.swapPrice,
	}

	tm.totalAmount -= tradedTokens
	tm.amountInProgress += tradedTokens

	sd := &SwapDriver{
		nostr:  tm.nostr,
		seller: tm.seller,
		buyer:  tm.buyer,

		saleId:       tm.saleId,
		swapId:       msg.SwapId,
		tradeDetails: trade,

		stage: DriverStageAcceptedBuy,
	}

	tm.inflightTrades = append(tm.inflightTrades, sd)

	resp := MsgAcceptBuy{
		SwapId:      sd.swapId,
		SellAddress: tm.buyer.Address(),
		Amount:      trade.Amount,
		SwapPrice:   trade.Price,
	}

	data, err := json.Marshal(resp)
	if err != nil {
		log.Error().Err(err).Msg("Can not encode accept msg")
		return
	}

	if err := tm.nostr.PublishDirectMessage(ctx, sender, []string{"s", tm.saleId}, string(data)); err != nil {
		log.Error().Err(err).Msg("Can not send buy accepted message")
		return
	}

	log.Info().Msg("Sent atomic swap buy offer accept")
}

func (sd *SwapDriver) handleAcceptBuy(ctx context.Context, sender string, msg MsgAcceptBuy) {
	log.Info().Msg("Seller accepted our buy offer")

	initiateOutput, secret, secretHash, err := sd.buyer.InitPayment(ctx, msg.Amount, msg.SwapPrice, msg.SellAddress)
	if err != nil {
		log.Error().Err(err).Msg("Failed to initiate  swap")
		return
	}

	sd.tradeDetails = NegotiatedTrade{Amount: msg.Amount, Price: msg.SwapPrice}
	sd.secret = secret
	sd.secretHash = secretHash
	sd.stage = DriverStageSetupSwap

	log.Info().Msgf("Submitted initiate transaction")

	resp := MsgInitiate{
		SwapId:         sd.swapId,
		SharedSecret:   secretHash,
		InitiateOutput: initiateOutput,
		StellarAddress: sd.seller.Address(),
	}

	data, err := json.Marshal(resp)
	if err != nil {
		log.Error().Err(err).Msg("Can not encode initiate  message")
		return
	}

	if err := sd.nostr.PublishDirectMessage(ctx, sender, []string{"s", sd.saleId}, string(data)); err != nil {
		log.Error().Err(err).Msg("Can not send buy accepted message")
		return
	}

	log.Info().Msg("Set up atomic swap, notified seller")

}

func (sd *SwapDriver) handleInitiate(ctx context.Context, sender string, msg MsgInitiate) {
	// First validate init payment
	ssh, err := sd.buyer.ValidateInitPaymentResult(ctx, msg.InitiateOutput, sd.tradeDetails)
	if err != nil {
		log.Warn().Err(err).Msg("Init payment validation failed")
		return
	}

	// Now create TFT contract
	participateOutput, err := sd.seller.InitTFTTransfer(ctx, sd.tradeDetails, msg.SharedSecret, msg.StellarAddress)
	if err != nil {
		log.Error().Err(err).Msg("Failed to lock TFT in contract")
		return
	}

	sd.secretHash = ssh
	sd.stage = DriverStageParticipateSwap

	resp := MsgParticipate{
		SwapId:            sd.swapId,
		ParticipateOutput: participateOutput,
	}
	data, err := json.Marshal(resp)
	if err != nil {
		log.Error().Err(err).Msg("Can not encode redeemed msg")
		return
	}

	if err := sd.nostr.PublishDirectMessage(ctx, sender, []string{"s", sd.saleId}, string(data)); err != nil {
		log.Error().Err(err).Msg("Can not send buy accepted message")
		return
	}

	log.Info().Msg("Setup atomic swap on TFT side")
}

func (sd *SwapDriver) handleParticipate(ctx context.Context, sender string, msg MsgParticipate) {
	if err := sd.seller.ValidateTFTTranser(ctx, msg.ParticipateOutput, sd.tradeDetails, sd.secretHash); err != nil {
		log.Warn().Err(err).Msg("TFT transfer validation failed")
		return
	}

	if err := sd.seller.ClaimTFT(ctx, msg.ParticipateOutput, sd.secret); err != nil {
		log.Error().Err(err).Msg("Could not claim TFT")
		return
	}

	log.Info().Msg("Contract TFT redeemed")

	// Strictly speaking it is not necessary to communicate the secret to the receiver as he can extract it from the redeem transaction
	// In fact, the seller should loop and periodically check if the contract has been redeemed, and extract the secret if it has. However
	// for now we will be courtious and notify him, while including the secret. In the end, a swap driver should continuosly build state
	// with received info to the point where he can do this on his own (this => extract secret), so that a simple "it's done" is enough
	resp := MsgRedeemed{
		SwapId: sd.swapId,
		Secret: sd.secret,
	}

	data, err := json.Marshal(resp)
	if err != nil {
		log.Error().Err(err).Msg("Can not encode redeemed msg")
		return
	}

	sd.stage = DriverStageClaimSwap

	if err := sd.nostr.PublishDirectMessage(ctx, sender, []string{"s", sd.saleId}, string(data)); err != nil {
		log.Error().Err(err).Msg("Can not send buy accepted message")
		return
	}

	log.Info().Msg("Redeemed atomic swap on Stellar side, notified seller, we have our TFT now")
}

func (sd *SwapDriver) handleRedeem(ctx context.Context, sender string, msg MsgRedeemed) {
	// So now we have a secret, for now implicitly trust the remote
	// We already validated the contract in the previous step
	redeemOutput, err := sd.buyer.Claim(ctx, sd.initResult, sd.secretHash, msg.Secret)
	if err != nil {
		log.Error().Err(err).Msg("Failed to redeem contract")
		return
	}
	log.Info().Str("Tx hash", redeemOutput).Msg("Contract redeemed")

	log.Info().Msg("Redeemed atomic swap seller side, we have our tokens now")

	sd.stage = DriverStageDone
}

func handleMessage(driver *TradeManager) {
	log.Debug().Msg("Start to handle swap messages")
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	for evt := range driver.msges {
		sid := struct {
			SwapId string `json:"swapId"`
		}{}
		if err := json.Unmarshal([]byte(evt.Content), &sid); err != nil {
			log.Debug().Err(err).Msg("could not decode buy message in atomic swap driver")
			continue
		}

		// no swap id so its a message for the initial stage of the seller
		if sid.SwapId == "" {
			// Sanity check that we are selling
			if driver.saleId == "" {
				log.Info().Msg("Invalid message received which has neither sale ID or swap ID set")
				continue
			}
			// At this point we MUST have a buy message
			msg := MsgBuy{}
			if err := json.Unmarshal([]byte(evt.Content), &msg); err != nil {
				log.Debug().Err(err).Msg("could not decode buy message in atomic swap driver")
				continue
			}
			driver.handleBuyMessage(ctx, evt.PubKey, msg)
		} else {
			var sd *SwapDriver
			for _, s := range driver.inflightTrades {
				if sd.swapId == sid.SwapId {
					sd = s
					break
				}
			}
			if sd == nil {
				log.Info().Str("Swap ID", sid.SwapId).Msg("Got swap message for unknown ID")
				continue
			}

			switch sd.stage {
			case DriverStageStartBuy:
				msg := MsgAcceptBuy{}
				if err := json.Unmarshal([]byte(evt.Content), &msg); err != nil {
					log.Debug().Err(err).Msg("could not decode buy accept message in atomic swap driver")
					continue
				}
				sd.handleAcceptBuy(ctx, evt.PubKey, msg)
			case DriverStageAcceptedBuy:
				msg := MsgInitiate{}
				if err := json.Unmarshal([]byte(evt.Content), &msg); err != nil {
					log.Debug().Err(err).Msg("could not decode initiate eth message in atomic swap driver")
					continue
				}
				sd.handleInitiate(ctx, evt.PubKey, msg)
			case DriverStageSetupSwap:
				msg := MsgParticipate{}
				if err := json.Unmarshal([]byte(evt.Content), &msg); err != nil {
					log.Debug().Err(err).Msg("could not decode participate stellar message in atomic swap driver")
					continue
				}
				sd.handleParticipate(ctx, evt.PubKey, msg)
			case DriverStageParticipateSwap:
				msg := MsgRedeemed{}
				if err := json.Unmarshal([]byte(evt.Content), &msg); err != nil {
					log.Debug().Err(err).Msg("could not decode redeemed message in atomic swap driver")
					continue
				}
				sd.handleRedeem(ctx, evt.PubKey, msg)
			}
		}
	}
}
